---
layout: post
title: HTTP协议版本
category: blog
description: HTTP协议版本
---

## HTTP 1.0和HTTP 1.1主要区别
### 缓存
#### HTTP1.0原有头部
##### Expire
文件在本地缓存的过期时间（绝对时间），如果浏览器发现缓存中的文件没有过期，则不发送请求。

在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。

##### Progma
Pragma:no-cache头域，客户端使用该头域说明请求资源不能从cache中获取，而必须回源获取。

在HTTP 1.1协议中，它的含义和Cache-Control:no-cache相同。

##### Last-Modefied/If-Modified-Since
Last-Modified/If-Modified-Since要配合Cache-Control使用。

Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。

If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP 200；若最后修改时间较旧，说明资源无新修改，则响应HTTP 304(无需包体，节省浏览)，告知浏览器继续使用所保存的cache。

#### HTTP1.1新增头部
##### Cache-control
Cache-Control与Expires的作用一致，都是指明当前资源的有效期，控制浏览器是否直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。

值可以是public、private、no-cache、no- store、no-transform、must-revalidate、proxy-revalidate、max-age，各个消息中的指令含义如下：

- Public指示响应可被任何缓存区缓存。
- Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。
- no-cache指示请求或响应消息不能缓存，该选项并不是说可以设置”不缓存“，容易望文生义~
- no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存，完全不存下來。
- max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。
- min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。
- max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。

##### Etag/If-none-match
Etag/If-None-Match也要配合Cache-Control使用。

Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。

If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器收到请求后发现有头If-None-Match 则与被请求资源的相应校验串进行比对，决定返回200或304。

#### 内容协商机制

Cache使用关键字索引在磁盘中缓存的对象，在HTTP 1.0中使用资源的URL作为关键字。但可能存在不同的资源基于同一个URL的情况，要区别它们还需要客户端提供更多的信息，如Accept-Language和Accept-Charset头域。为了支持这种内容协商机制(content negotiation mechanism)，HTTP 1.1在响应消息中引入了Vary头域，该头域列出了请求消息中需要包含哪些头域用于内容协商。

### 长连接
HTTP 1.0需要使用keep-alive参数来告知服务器端要建立一个长连接，而HTTP1.1默认支持长连接。

HTTP 1.0规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

在HTTP 1.0中，要建立长连接，可以在请求消息中包含Connection: Keep-Alive头域，如果服务器愿意维持这条连接，在响应消息中也会包含一个Connection: Keep-Alive的头域。同时，可以加入一些指令描述该长连接的属性，如max，timeout等。

HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。

HTTP 1.1还允许客户端不用等待上一次请求结果返回，就可以发出下一次请求，但服务器端必须按照接收到客户端请求的先后顺序依次回送响应结果，以保证客户端能够区分出每次请求的响应内容。

### 带宽优化
HTTP 1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了。

HTTP 1.1中在请求消息中引入了range头域，它允许只请求资源的某个部分。在响应消息中Content-Range头域声明了返回的这部分对象的偏移值和长度。

另外一种情况是请求消息中如果包含比较大的实体内容，但不确定服务器是否能够接收该请求（如是否有权限），此时若贸然发出带实体的请求，如果被拒绝也会浪费带宽。

HTTP 1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。

### HOST头部
在HTTP 1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址和端口。

HTTP 1.1的请求消息和响应消息都应支持Host头部，且请求消息中如果没有Host头部会报告一个错误（400 Bad Request）。

## HTTP2.0的特点
### 二进制分帧层
HTTP 2.0性能增强的核心，全在于新增的二进制分帧层，它定义了如何封装HTTP消息并在客户端与服务器之间传输。
![](/images/posts/2017-07-06-HTTP协议版本/http_1.jpg)
在二进制分帧层中， HTTP 2.0会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码，其中HTTP1.x的首部信息会被封装到HEADER frame，而相应的Request Body则封装到DATA frame里面。

接下来说的几个特点都是基于这个机制来实现的。

### 流、消息和帧
![](/images/posts/2017-07-06-HTTP协议版本/http_2.jpg)
所有HTTP 2.0通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。

每个数据流以消息的形式发送，而消息由一或多个帧组成，这些帧可以乱序发送，然后再根据每个帧首部的流标识符重新组装。
![](/images/posts/2017-07-06-HTTP协议版本/http_3.jpg)

### 多路复用 (Multiplexing)
多路复用允许同时通过单一的HTTP 2.0连接发起多重的请求-响应消息。

众所周知，在HTTP 1.1协议中「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」，下图总结了不同浏览器对该限制的数目。
![](/images/posts/2017-07-06-HTTP协议版本/http_4.png)
这也是为何一些站点会有多个静态资源CDN域名的原因之一，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而HTTP 2.0的多路复用(Multiplexing)则允许同时通过单一的HTTP 2.0连接发起多重的请求-响应消息。
![](/images/posts/2017-07-06-HTTP协议版本/http_5.png)
因此HTTP 2.0可以很容易的去实现多流并行而不用依赖建立多个TCP连接，HTTP 2.0把HTTP协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个TCP连接上双向交换消息。

### 请求优先级
把HTTP消息分解为很多独立的帧之后，就可以通过优化这些帧的交错和传输顺序，进一步提升性能。为了做到这一点，每个流都可以带有一个31比特的优先值。

如果服务器不理睬优先值，可能导致应用响应变慢：浏览器明明在等关键的CSS和JavaScript，服务器却在发送图片，从而造成渲染阻塞。

### 服务器推送
服务器除了对最初请求的响应外，服务器还可以额外向客户端推送资源，而无需客户端明确地请求。
![](/images/posts/2017-07-06-HTTP协议版本/http_6.jpg)

### 首部压缩
在HTTP1.x中，首部元数据都是以纯文本形式发送的，通常会给每个请求增加500~800字节的负荷。为减少这些开销并提升性能，HTTP 2.0会压缩首部元数据。

HTTP 2.0连接的两端都知道已经发送了哪些首部，这些首部的值是什么，从而可以针对之前的数据只编码发送差异数据。

![](/images/posts/2017-07-06-HTTP协议版本/http_7.jpg)